<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Weather Report</title>
</head>
<body>
<div>
    <input type="hidden" id="gridX" th:value="${weather.gridX}">
    <input type="hidden" id="gridY" th:value="${weather.gridY}">

</div>


<div id="weather-data"></div>


</body>

<script>
    function getNextForecastTime() {
        let now = new Date();
        let nextForecastHour = Math.floor(now.getHours() / 3) * 3 - 1;
        if(nextForecastHour.toString().padStart(2, '0') === '00' || nextForecastHour.toString().padStart(2, '0') === '01' || nextForecastHour.toString().padStart(2, '0') === '02') {
            return '2300';
        }
        if(Math.floor(now.getHours())% 3 === 2 && now.getMinutes() >= 11) {
            return Math.floor(now.getHours()).toString().padStart(2, '0') + '00';
        }
        console.log(nextForecastHour.toString().padStart(2, '0') + '10');
        return nextForecastHour.toString().padStart(2, '0') + '00'; // 예: '0210', '0510'
    }

    function getWeather(gridX, gridY) {
        console.log("Fetching weather for coordinates:", gridX, gridY); // Debugging log
        var forecastTime = getNextForecastTime(); // 다음 예보 시간 계산
        var currentDate = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        console.log(forecastTime);
        console.log(currentDate);
        var xhr = new XMLHttpRequest();
        var url = 'https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst';
        var queryParams = '?' + encodeURIComponent('serviceKey') + '=' + 'hogAXADhx1TwUFYu9kBfwwvsv5m%2FwsLzvQT2tBT0BFSH3eLnXp88Dx%2FR6x2GCPtWKfaUQEPix2VcWYEp0Hz5Tw%3D%3D';
        queryParams += '&' + encodeURIComponent('pageNo') + '=' + encodeURIComponent('1');
        queryParams += '&' + encodeURIComponent('numOfRows') + '=' + encodeURIComponent('37'); //12개씩 적용 12*4 = 48
        queryParams += '&' + encodeURIComponent('dataType') + '=' + encodeURIComponent('XML');
        queryParams += '&' + encodeURIComponent('base_date') + '=' + encodeURIComponent(currentDate);
        queryParams += '&' + encodeURIComponent('base_time') + '=' + encodeURIComponent(forecastTime);
        queryParams += '&' + encodeURIComponent('nx') + '=' + encodeURIComponent(gridX);
        queryParams += '&' + encodeURIComponent('ny') + '=' + encodeURIComponent(gridY);
        xhr.open('GET', url + queryParams);
        xhr.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200) {
                displayWeatherData(this.responseXML);
            }
        };
        xhr.send();
    }

    function calculateCurrentTime() {
        let now = new Date();
        let currentTime = Math.floor(now.getHours()) * 100 - getNextForecastTime() - 100;
        return currentTime / 100;
    }
    function displayWeatherData(xml) {
        const items = xml.getElementsByTagName("item");
        let weatherData = {};
        let startPoint = calculateCurrentTime();
        console.log(startPoint * 12);
        // 데이터 구조화
        console.log("아이템 length : " + items.length);
        for (let i = startPoint * 12; i < (items.length /3 - 1) * (startPoint + 1); i++) {
            const category = items[i].getElementsByTagName("category")[0].childNodes[0].nodeValue;
            const value = items[i].getElementsByTagName("fcstValue")[0].childNodes[0].nodeValue;
            const time = items[i].getElementsByTagName("fcstTime")[0].childNodes[0].nodeValue;

            if (!weatherData[time]) {
                weatherData[time] = {};
            }
            weatherData[time][category] = value;
        }

        let output = "";
        output += "<table class='table table-striped table-hover'><thead class='table-dark'><tr><th>Time</th><th>Temperature (°C)</th><th>Wind Speed (m/s)</th><th>Humidity (%)</th><th>Precipitation</th><th>Sky Condition</th><th>Weather Icon</th></tr></thead><tbody>";

        for (const [time, data] of Object.entries(weatherData)) {
            const weatherIcon = getWeatherIcon(parseInt(data['SKY']), parseInt(data['PTY']));
            output += `<tr>
                <td>${time}</td>
                <td>${data['TMP'] || '—'}</td>
                <td>${data['WSD'] || '—'}</td>
                <td>${data['REH'] || '—'}</td>
                <td>${data['PCP'] || '—'}</td>
                <td>${data['SKY'] || '—'}</td>
                <td>${weatherIcon || '—'}</td>
              </tr>`;
        }

        output += "</tbody></table>";
        document.getElementById("weather-data").innerHTML = output;
    }

    document.addEventListener("DOMContentLoaded", function() {
        var gridX = document.getElementById('gridX').value;
        var gridY = document.getElementById('gridY').value;
        if (gridX && gridY) {
            getWeather(gridX, gridY);
        }
    });

</script>

<script>
    function getWeatherIcon(sky, precipitation) {
        const icons = {
            clear: '☀️', // 맑음 아이콘
            cloudy: '🌥', // 구름많음 아이콘
            overcast: '☁️', // 흐림 아이콘
            rain: '🌧', // 비 아이콘
            sleet: '🌨', // 비/눈 아이콘
            snow: '❄️', // 눈 아이콘
            shower: '⛈' // 소나기 아이콘
        };

        // 하늘 상태를 기반으로 아이콘 설정
        let icon = '';
        switch(sky) {
            case 1: // 맑음
                icon = icons.clear;
                break;
            case 3: // 구름많음
                icon = icons.cloudy;
                break;
            case 4: // 흐림
                icon = icons.overcast;
                break;
            default:
                icon = '';
        }

        // 강수 형태에 따라 아이콘을 추가
        switch(precipitation) {
            case 1: // 비
                icon = icons.rain;
                break;
            case 2: // 비/눈
                icon = icons.sleet;
                break;
            case 3: // 눈
                icon = icons.snow;
                break;
            case 4: // 소나기
                icon = icons.shower;
                break;
            default:
        }

        return icon;
    }

</script>

</html>
